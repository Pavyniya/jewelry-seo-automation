import { AiServiceImpl } from '../aiService';

// Mock the repositories
jest.mock('../../repositories/aiProviderRepository');
jest.mock('../../repositories/aiUsageRepository');

// Mock the AI SDKs
const mockOpenAICreate = jest.fn();
jest.mock('openai', () => {
  return jest.fn().mockImplementation(() => {
    return {
      chat: {
        completions: {
          create: mockOpenAICreate,
        },
      },
    };
  });
});

const mockAnthropicCreate = jest.fn();
jest.mock('@anthropic-ai/sdk', () => {
  return {
    Anthropic: jest.fn().mockImplementation(() => {
      return {
        messages: {
          create: mockAnthropicCreate,
        },
      };
    }),
  };
});

const mockGoogleAIGenerate = jest.fn();
jest.mock('@google/generative-ai', () => {
  return {
    GoogleGenerativeAI: jest.fn().mockImplementation(() => {
      return {
        getGenerativeModel: jest.fn().mockReturnValue({
          generateContent: mockGoogleAIGenerate,
        }),
      };
    }),
  };
});

describe('AiService', () => {
  let aiService: AiServiceImpl;
  let aiProviderRepository: any;
  let aiUsageRepository: any;

  beforeEach(async () => {
    jest.resetModules();

    // Re-import modules for each test
    aiProviderRepository = require('../../repositories/aiProviderRepository').aiProviderRepository;
    aiUsageRepository = require('../../repositories/aiUsageRepository').aiUsageRepository;

    // Mock repository methods
    (aiProviderRepository.findAll as jest.Mock).mockResolvedValue([
      { id: '1', name: 'gemini', isEnabled: true },
      { id: '2', name: 'claude', isEnabled: true },
      { id: '3', name: 'gpt', isEnabled: true },
    ]);
    (aiProviderRepository.create as jest.Mock).mockImplementation(async (item) => item);
    (aiUsageRepository.create as jest.Mock).mockResolvedValue({});

    const { AiServiceImpl } = require('../aiService');
    aiService = new AiServiceImpl();
    await aiService.reloadProviders(); // Ensure providers are loaded
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should initialize and load providers', () => {
    expect(aiProviderRepository.findAll).toHaveBeenCalled();
  });

  it('should use the primary provider (gemini) successfully', async () => {
    mockGoogleAIGenerate.mockResolvedValue({
      response: {
        text: () => 'Generated by Gemini',
      },
    });

    const result = await aiService.generateContent('test prompt');

    expect(result.provider).toBe('gemini');
    expect(result.content).toBe('Generated by Gemini');
    expect(aiUsageRepository.create).toHaveBeenCalledWith(expect.objectContaining({ success: true }));
  });

  it('should failover to the next provider (claude) if the first one fails', async () => {
    mockGoogleAIGenerate.mockRejectedValue(new Error('Gemini failed'));
    mockAnthropicCreate.mockResolvedValue({
      content: [{ type: 'text', text: 'Generated by Claude' }],
      usage: { input_tokens: 10, output_tokens: 20 },
    });

    const result = await aiService.generateContent('test prompt');

    expect(result.provider).toBe('claude');
    expect(result.content).toBe('Generated by Claude');
    expect(aiUsageRepository.create).toHaveBeenCalledWith(expect.objectContaining({ success: false, errorMessage: 'Gemini failed' }));
    expect(aiUsageRepository.create).toHaveBeenCalledWith(expect.objectContaining({ success: true }));
  });

  it('should throw an error if all providers fail', async () => {
    // Suppress console.error during this test to avoid noise
    const originalError = console.error;
    console.error = jest.fn();

    mockGoogleAIGenerate.mockRejectedValue(new Error('Gemini failed'));
    mockAnthropicCreate.mockRejectedValue(new Error('Claude failed'));
    mockOpenAICreate.mockRejectedValue(new Error('OpenAI failed'));

    await expect(aiService.generateContent('test prompt')).rejects.toThrow(/All AI providers failed to generate content/);

    // Restore console.error
    console.error = originalError;
  });
});
